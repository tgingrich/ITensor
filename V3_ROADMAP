(! means necessary / blocker for releasing v3)

# Breaking changes to library code:
! Add alternative to niter which starts at 1. Solver iterations? Eigen iterations?
  --> Matt: see https://github.com/ITensor/ITensor/issues/209
! Bondgate class improvements
? Move idmrg into a seperate code

# Non-breaking, but nice to have for V3:
o Improvements to SiteSet:
  o IndexSet -> SiteSet conversion
  o Make `op()`, a free version of `.op()`
o Bring over new "iterInds" feature from v2
  -> Just added: http://itensor.org/support/1361/iterating-over-non-zero-elements-of-a-sparse-itensor)
o Make diagHermitian tag-friendly
  -> Generalize to `diagHermitian(H,{i,j},{k,l})`, where `H==swapInds(dag(H),{i,j},{k,l})`
o Make MPS/MPO functions tag-friendly:
  o Make DMRG tag-friendly
    -> Output MPS has tags of input MPS
    -> Don't require input MPS to have tags "Site" and "Link"
    -> Allow MPO that don't have site indices that are primes of each other
  o Make applyExpH tag-friendly
    -> Output MPS has tags of input MPS
    -> Don't require input MPS to have tags "Site" and "Link"
o Make a version of DMRG that is not in-place:
  -> `auto [psi,E] = dmrg(H,psi0,args)`

# Github:
! Update branch names on Github (rc3 -> v3)

# Website:
! Update website:
  o Detailed documentation
    - See Github issue list
    - info about QN blocks in Index objects
    X how to make QN ITensors
    - removeQNs ITensor function
    - removeQNs MPS function
  o List of deprecrations/guide to update code
  o ITensor book
    - Update TRG to show use of Tags
    - TRG code (book/trg.cc)
  o Tutorials
  o Code formulas


# Final Release Checks
  ! Fresh install with new options.mk file compiles
  ! Jenkins is passing
  ! All sample codes compile and run and are up to date
  ? Incorporate sample codes into Jenkins/testing 
    (I found the DMRG codes were useful for catching bugs, 
     and TRG is a good test case for Tags)
    Miles say: Yes I agree. We could put copies of the sample codes
    or crucial sections of the sample codes into the unit
    tests. Maybe for the DMRG one just do one sweep.
    Or perhaps better, Dylan can config Jenkins to 
    compile the sample codes.

#################################################################################################
Completed (this is to help keep track of changes made, but we should make an official
           list for the website):

# Miscellaneous

 - Changed license to Apache 2.0 per Flatiron Institute policy

# Common operation changes and deprecations (for upgrade guide):

 - Index, IndexSet, IndexVal operations:

  o More IndexSet set operations:
    o Add `==(IndexSet,IndexSet)` to check if they are equal (subsets of one another)
    o Add `hasInds(IndexSet,IndexSet)` to check if one is a subset of another
    o Add `unionInds(IndexSet,IndexSet)->IndexSet` and `unionInds({IndexSet,IndexSet,...})` to get set union
    o Add `uniqueInds(IndexSet,IndexSet)` and `uniqueInds(IndexSet,{IndexSet,...})` to get set difference
    o Add `commonInds(IndexSet,IndexSet)` to get set intersection
    o Add `noncommonInds(IndexSet,IndexSet)` to get set symmetric difference
    o Add `findInds(IndexSet,TagSet)` to get a subset containing tags in the tagset
    o Add `findIndsExcept(IndexSet,TagSet)` to get a subset not containing tags in the tagset
  o Add `sim(IndexSet)`, `sim(IndexSet,IndexSet)`, `sim(IndexSet,TagSet)` to replace indices in an IndexSet with
    similar indices
  o Tagging functions (added to Index and IndexVal):
    o setTags
    o noTags
    o addTags
    o removeTags
    o replaceTags
    o prime
    o setPrime
    o noPrime
  o Add conversion of `std::initializer_list<Index>`,`std::array<Index,N>`, and `std::vector<Index>` to `IndexSet`
  o Removed `mapPrime(1,2,...)`, use `replaceTags("1","2",...)` instead
    -> Uses of `mapPrime` are superseded by `replaceTags`, `setPrime`, `replaceInds`, etc.
  o Prime level can be accessed through TagSet, i.e. `findIndex(A,"Site,1")` means Index with
    tag "Site" and prime level 1
  o `sim(Index)` now by default keeps the prime level of the Index instead of setting to zero
  o `Index.dir(Arrow)` -> `Index.setDir(Arrow)`
  o Added `dir(Index)` as preferred alternative to `Index.dir()`
  o Changed index constructor from `Index("i",2)` -> `Index(2,"i")` (deprecation error)
  o noprime -> noPrime (deprecation error)
  o Added `dim(Index)` as preferred alternative to `Index.m()`, changed throughout library (TODO: add deprecation warning?)
  o Removed `findIndex(IndexSet const& is, Arrow dir)` (use `findIndex(IndexSet,TagSet)` instead)
  o Added `id(Index)` as preferred alternative to `Index.id()`
  o Remove IQTensor and IQIndex types, merging with ITensor and Index (also
    removed IQIndexVal, IQMPS, IQMPO, etc)
  o Add `findIndex(ITensor,TagSet) -> Index`, which finds the Index in the ITensor 
    containing certain tags
  o Remove `findType`, use `findIndex` instead

 - ITensor operations:

  o Add `maxDim(ITensor)` and `minDim(ITensor)`
  o Optimize `A*delta(i,j)` contraction so that if `A` has Index `i` or `j` (but not both), 
    no contraction occurs and the Index is just replaced in the IndexSet
  o Add versions of ITensor decompositions that return tuples of outputs:
    o `svd(ITensor,IndexSet[,IndexSet]) -> tuple<ITensor,ITensor,Index,Index>`
    o `factor(ITensor,IndexSet[,IndexSet]) -> tuple<ITensor,ITensor,Index>`
    o `denmatDecomp(ITensor,IndexSet[,IndexSet]) -> tuple<ITensor,ITensor,Index>`
    o `diagHermitian(ITensor) -> tuple<ITensor,ITensor,Index>`
    o `eigen(ITensor) -> tuple<ITensor,ITensor,Index>`
  o More Index operations:
    o `findIndex(ITensor,TagSet)` to get the index that has tags in a TagSet (throws error if there are more than one)
    o `findInds(ITensor,TagSet)` to get all indices that have the tags in a TagSet
    o `hasInds(ITensor,IndexSet)` to see if the ITensor has the specified Indices
  o Tagging functions:
    o setTags
    o noTags
    o addTags
    o removeTags
    o replaceTags
    o swapTags
    o prime
    o setPrime
    o noPrime
  o Add `swapInds(A,{i,j,k},{a,b,c})` to swap the Indices i<->a, j<->b, etc.
  o All ITensor constructors like `ITensor(...)`, `randomITensor(...)`, `diag(...)`, etc. now accept
    `std::initializer_list<Index>`,`std::array<Index,N>`, `std::vector<Index>`, and `IndexSet`
    along with vararg lists of `Index,Index...`
  o Added `uniqueInds(A,{B,C})` and `uniqueIndex(A,{B,C}[,ts])` notation for getting the unique indices/index under
    a certain tag constraint
  o Allow tag and prime functions to accept multiple indices for matching
    o Also allow IndexSet for matching
  o Add `inds(ITensor)` as preferred alternative to `ITensor.inds()`
  o Add `index(ITensor,int)` as preferred alternative to `ITensor.index(int)`
  o New QN design:
    Store a smallstring along with QN value and mod fac. Storage is an array (fixed-size)
    of triples name-val-modfac.
  o `order(A,i,j,k)` -> `permute(A,i,j,k)` to permute the data of an ITensor
  o Removed `permute(A,i,j,"...")` syntax (it is confusing with TagSets, now can be done with 
    `permute(A,unionInds({i,j},uniqueInds(inds(A),{i,j})))`
  o Add deprecation warning for prime(ITensor,Index,int) pointing towards prime(ITensor,int,Index)
  o Renamed ITensor .real and .cplx to .elt and .eltC; kept .real and .cplx just for
    backwards compatibility. Replaced throughout library.
  o Replace maxM(IndexSet) and minM(IndexSet) with maxDim(IndexSet) and minDim(IndexSet)
  o Deprecate "Maxm", "Minm" args in favor of "MaxDim", "MinDim" in svd(), diagHermitian(), factorize(), dmrg(), idmrg(), etc.
    -> Added warning in all functions that use "Maxm" and "Minm", saying to use "MaxDim" and "MinDim"
  o Deprecate randomize(ITensor& T) in favor of T.randomize()
  o Remove IQTensor and IQIndex types, merging with ITensor and Index (also
    removed IQIndexVal, IQMPS, IQMPO, etc)
  o Deprecate reindex(ITensor,Index,Index,...), replace with replaceInds(ITensor,IndexSet,IndexSet)
    that does not ignore prime levels and internally calls delta() (deprecation error)
  o Deprecate randomTensor, matrixTensor, diagTensor in favor of randomITensor, matrixITensor, diagITensor (deprecation warnings)
  o Added .elt and .eltC accepting vector<int> (pull #194)
  o Added .elt(vector<IndexVal>), .eltC(vector<IndexVal>), etc.
  o Test removeQNs is working correctly for QDiag -> Diag case. Remove the toDense function.
  o Change name of findIndex(ITensor,Index) -> int to indexPosition(ITensor,Index) -> int

 - MPS operations:

  o Rename `HubbardSite` -> `ElectronSite` (deprecated with a typedef)
  o Rename `SpinlessSite` -> `FermionSite` (deprecated with a typedef)
  o Add hasQNs(MPS)
  o Deprecate overlap(x,y) in favor of inner(x,y) (overlap is deprecated with a warning)
    o Right now, inner(x,y) conjugates x and then matches the indices of dag(x) and y
  o Add `siteInds(MPS) -> IndexSet` to get an ordered IndexSet of the site indices
  o Add `linkInds(MPS) -> IndexSet` to get an ordered IndexSet of the link indices
  o Add `replaceSiteInds(MPS,IndexSet) -> MPS` to make a new MPS with site indices replaces by those in the IndexSet
  o Add `replaceLinkInds(MPS,IndexSet) -> MPS` to make a new MPS with link indices replaces by those in the IndexSet
  o `.position(int)`, `.orthogonalize()`, and `.svdBond()` accept inputs with any tag convention and keep the proper tags of
    the input MPS/MPO
  o Added `addTags(MPS,...)`, `replaceTags(MPS,...)`, `prime(MPS,...)`, etc.
  o Add `linkIndex(MPS,int) -> Index` and `siteIndex(MPS,int)` to get the right link index and site index of an MPS
    o Add `linkInds(MPS/MPO,int) -> IndexSet` to get the link indices of an MPS/MPO tensor
    o Add `leftLinkIndex(MPS/MPO,int) -> Index` and `rightLinkIndex(MPS/MPO,int)` to get the left/right link index of an MPS/MPO
  o Remove SiteSet from MPS class (no more MPS.site())
  o Deprecate `MPO.primeall()` in favor of `MPO.prime()`
  o Add MPS/MPO method `.primeLink(...)` to prime only the link indices
  o psi.A(i) -> psi(i), psi.Aref(i) -> psi.ref(i), psi.setA(i,T) -> psi.set(i,T) (no warning or error)
  o psi.N() -> length(psi)
  o Tagging functions:
    o setTags
    o noTags
    o addTags
    o removeTags
    o replaceTags
    o swapTags
    o prime
    o setPrime
    o noPrime
  o Replace maxM(MPS) and averageM(MPS) with maxLinkDim(MPS) and averageLinkDim(MPS)
  o Deprecate "Maxm", "Minm" args in favor of "MaxDim", "MinDim" in svd(), diagHermitian(), factorize(), dmrg(), idmrg(), etc.
    -> Added warning in all functions that use "Maxm" and "Minm", saying to use "MaxDim" and "MinDim"
  o Deprecate normalize(MPS& psi) in favor of psi.normalize()
  o Better tag convention for labelling site index (i.e. "n=1" instead of "1" for site 1)
    o Site and Link IndexTypes removed in favor of tags
    o Make sure that "Link" index keeps a consistent convention for labelling which link
      (i.e. MPS at site "n=4" should have left link with tags "Link,l=3" and right link with
       tags "Link,l=4")
  o All site sets except SiteSet(N,d) default to ConserveQNs=true
  o Test that new QN system allows mixing different site types
    (--> add MixedSiteSet to docs)
  o Change default behavior of MPS(sites,m) constructor to be uninitialized MPS of size m
    o m>1 only allowed with no QNs
  o Add randomMPS(SiteSet,m=1) function with no QNs
  o Add randomMPS(InitState) function for QNs and no QNs
  o Remove dependency of itensor/mps/localop.h in itensor/decomp.h (this seemed to be the only itensor/mps/ dependency left in itensor/)

 - MPO operations:

  o Add hasQNs(MPO)
  o Add `replaceSiteInds(MPO,IndexSet,IndexSet) -> MPO` to make a new MPO with specified site indices replaces by those in the IndexSet
  o Add `swapSiteInds(MPO) -> MPO` to "transpose" an MPO (swap the site indices, site by site)
  o Deprecate overlap(x,A[,B],y) in favor of inner(x,A[,B],y) (overlap is deprecated with a warning)
    o inner(x,A,y) = <x|A|y>, where the site indices of A|y> are matched to the site indices of <x|
    o inner(x,A,B,y) = <x|AB|y>, where the site indices of AB|y> are matched to the site indices of <x|
    o Also add inner(A,x,B,y) which does <Ax|By> (this helps to get the norm of A|x> with sqrt(innner(A,x,A,x))
  o Deprecate overlap(A,B) in favor of trace(A,B) (overlap is deprecated with a warning)
  o Add trace(A) to get the trace of an MPO
  o applyMPO(A,x) -> y, y now has the exact site indices of A|x> and the link tags of x (to allow more general tag conventions)
  o nmultMPO(A,B) -> C, C now has the exact site indices of AB and the link tags of A (to allow more general tag conventions)
  o Remove support for zipUpApplyMPO, exactApplyMPO, fitApplyMPO
  o Add `linkIndex(MPO,int)` and `siteIndex(MPO,int[,TagSet])` to get link and site indices
    -> Since there are two site indices, one can use a TagSet like "0" or "1" to decide which site index to grab
  o primeall(MPO) -> prime(MPO)
  o Tagging functions:
    o setTags
    o noTags
    o addTags
    o removeTags
    o replaceTags
    o swapTags
    o prime
    o setPrime
    o noPrime
  o Restore conversion of AutoMPO to MPO (allowing code like MPO(ampo)).
   o Add deprecation warning to MPO(AutoMPO), telling people to switch
     to toMPO(AutoMPO)
  o Added errMPOProd and deprecated checkMPOProd
 - DMRG operations:
  o Deprecate "Maxm", "Minm" args in favor of "MaxDim", "MinDim" in svd(), diagHermitian(), factorize(), dmrg(), idmrg(), etc.
    -> Added warning in all functions that use "Maxm" and "Minm", saying to use "MaxDim" and "MinDim"
  o In Sweeps object, added deprecation warning for .maxm() and .minm(), saying to use .maxdim() and .mindim()

Recent commits to v2:
  o errMPOProd and deprecation of checkMPOProd
  o More combiner constructors (combiner(IndexSet), combiner(initializer_list), etc.)
  o Bugfix for nmultMPO
  o More combiner constructors (combiner(IndexSet), combiner(initializer_list), etc.)

-----------------------------------------------

Optional (possibly post V3, because not breaking changes):
 --> TODO: add these as issues on Github
o Implement randomMPS(InitState,m>1)
  o Make initial MPS from initstate, then apply a random unitary circuit
  o Requires adding QR decomposition to make a random unitary
o Define QDense * Dense contraction directly
o Add MPS(std::vector<ITensor>) constructor
o PrintMatrix(ITensor,{Index,...},{Index,...}) function
  o Matt: the idea is to make a print function that doesn't just print the data of the ITensor
    as one big list, but instead print it in a grid that makes it look like a matrix. For example,
    for ITensor A with Index's i,j,k,l, PrintMatrix(A,{i,k},{l,j})
    prints A as if it were a matrix where the rows run over the combined Index (i,j) and
    the columns run over the combined index (l,j). I think this is especially useful
    for QN conserving ITensors, where it could make it easier to visualize
    blocks of the ITensor.
o Error for calls like Index(0,"i"), Index(QN(0),0,"j"), etc.
? In SiteSet, make all of the indices of the same type have the same ids but different tags
  -> Could make things like shifting gates easier

