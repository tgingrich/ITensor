(! means necessary / blocker for releasing v3)

! Update website:
  o Detailed documentation
    - info about QN blocks in Index objects
    X how to make QN ITensors
    - removeQNs ITensor function
    - removeQNs MPS function
  o List of deprecrations/guide to update code
  o Replace dim throughout documentation
  o ITensor book
    - Update TRG to show use of Tags
    - TRG code (book/trg.cc)
  o Tutorials
  o Code formulas

o Priming and tagging functions for MPS and MPO
  o primeall(MPO) -> prime(MPO)
o Finalize tags interface
  o Add `tags(IndexSet,string)` and `tags(ITensor,string)`
  o Remove whitespace from tags
  o Add access of prime level through the tag system
o Add alternative to niter which starts at 1. Solver iterations? Eigen iterations?
  --> Hard to make backwards compatible with table read mode
  ?-> Just change the definition by 1?
o Related: Make arnoldi, gmres, and davidson Args consistent
  o gmres and arnoldi have restarts, so there are two Args:
    the size of the Krylov space, and then the number of times
    they get restarted. Davidson doesn't have any restarts (but maybe
    it should?), so it just has the option of the Krylov size, which 
    equals the number of total iterations.
  o It seems common to specify the maximum Krylov size, and then
    also the maximum number of iterations, which means the algorithm
    gets restarted (maximum number of iterations) % (Krylov size) number
    of times. I think this is pretty standard, and good since it
    let's the user be explicit about the number of matrix-vector multiplications
    to perform
  o Matt's proposal: 
    - "MaxIterations" controls the total matrix-vector multiplies
    - "KrylovSize" ("SubspaceSize"???) controls the maximum Krylov space size
    `arnoldi` and `gmres` will have both of these, and davidson only has "MaxIterations"
    (or "KrylovSize"???).
    However, "MaxIterations" is not a great name for the DMRG interface, so
    maybe it gets translated to "SolverIterations"? But we also may want to
    leave the option open for having restarts/using a different solver,
    like Lanczos... I think this is something we need to discuss, since it
    gets pretty complicated.

# Final Release Checks
  ! Fresh install with new options.mk file compiles
  ! Jenkins is passing
  ! All sample codes compile and run and are up to date
  ? Incorporate sample codes into Jenkins/testing 
    (I found the DMRG codes were useful for catching bugs, 
     and TRG is a good test case for Tags)
    Miles say: Yes I agree. We could put copies of the sample codes
    or crucial sections of the sample codes into the unit
    tests. Maybe for the DMRG one just do one sweep.
    Or perhaps better, Dylan can config Jenkins to 
    compile the sample codes.

-----------------------------------------------

Optional (possibly post V3, because not breaking changes):
o Remove "Link" and "Site" from MPS and MPO functions
  o linkInd(psi,b)
  o rightLinkInd(psi,b)
  o leftLinkInd(psi,b)
  o DMRG, applyMPO, etc.
o Implement randomMPS(InitState,m>1)
  o Make initial MPS from initstate, then apply a random unitary circuit
o Define QDense * Dense contraction directly
o Make modifying functions member functions and all other functions free
  (at least for externally-facing functions)
o Add MPS(std::vector<ITensor>) constructor
o Generalize the convention for diagHermitian to accept a general pair of indices
  {ia,ja,ka,...,ib,jb,kb...} where ia==replaceTags(ib,tags(ib),tags(ia)), etc.
o Generalize the convention of DMRG and applyMPO to accept MPOs with more general
  tag conventions, not just {s1,s2,...,s1',s2',...}
? Change how MPS and MPO tensors are accessed
  o Make psi(b) get the MPS/MPO tensor at site b
  o psi.A(b) or psi.Aref(b) gets a reference to the MPS/MPO tensor in order to modify
  o Otherwise, we can just prefer psi.set(b,...) as the method for modifying an MPS tensor?
? Remove SiteSet from MPS class.
  o Matt: this would make it so that people can use MPS without SiteSet, if they
    want to do that, since SiteSet is a bit constrained and requires a lot of code
    to make an MPS on a set of sites that is not defined in ITensor.
    One can define siteInd(psi,b) = uniqueIndex(psi.A(b),psi.A(b-1),psi.A(b+1))
    to get a site index, and siteInds(psi) to extract the sites as a siteset
    to make another MPS with the same sites.
  o Note that the MPO class could also have SiteSet removed, and the sites could
    be defined by siteInds(H,b) = uniqueInds(H.A(b),H.A(b-1),H.A(b+1)) -> IndexSet to allow MPOs
    with arbitrary Index conventions, i.e. {i1,i2,i3,...,j1,j2,j3,...}
    Then, siteInds(H,b) can be used for tracing, for example H.A(b)*delta(siteInds(H,b))
? PrintMatrix(ITensor,{Index,...},{Index,...}) function
  o Matt: the idea is to make a print function that doesn't just print the data of the ITensor
    as one big list, but instead print it in a grid that makes it look like a matrix. For example,
    for ITensor A with Index's i,j,k,l, PrintMatrix(A,{i,k},{l,j}) 
    prints A as if it were a matrix where the rows run over the combined Index (i,j) and 
    the columns run over the combined index (l,j). I think this is especially useful 
    for QN conserving ITensors, where it could make it easier to visualize
    blocks of the ITensor.
? Add back some prime functions:
  o A.primeExcept(plinc=1,index1,index2,...)
  o A.primeExcept(plinc=1,tagset)
  o A.mapPrime(pold1,pnew1,index1,pold2,pnew2,index2,...)
? Add {"Randomize=",true} args for MPS(SiteSet)
  o Right now, just call randomMPS(siteset)
  o Matt: I prefer randomMPS(...) since it is consistent with randomITensor(...),
    though we could make ITensor(...) accept {"Randomize=",true} args
? Error for calls like Index(0,"i"), Index(QN(0),0,"j"), etc.
? Add some more tag functions
  o A.addTags(tagset,imatch1,imatch2,...)
? In site sets, make all of the indices have the same ids but different tags



#################################################################################################
Completed (this is to help keep track of changes made, but we should make an official
           list for the website):


o Replace .m() with dim(Index)
o Replace .id() with id(Index)
o Replace .N() with length(MPS)
o Replace maxM(MPS) and averageM(MPS) with maxLinkDim(MPS) and averageLinkDim(MPS)
o Replace maxM(IndexSet) and minM(IndexSet) with maxDim(IndexSet) and minDim(IndexSet)
o Deprecate maxM(MPS) and averageM(MPS) in favor of maxLinkDim(MPS) and averageLinkDim(MPS)
o Add length(MPS) as preferred alternative to MPS.N() to get length of MPS
o Add id(Index) as preferred alternative to .id()
o Deprecate normalize(MPS& psi) in favor of psi.normalize()
o Deprecate randomize(ITensor& T) in favor of T.randomize()
o Deprecate i.m() in favor of dim(i), replace throughout library
o Test removeQNs is working correctly for QDiag -> Diag case. Remove the toDense function.
o Added .real and .cplx accepting vector<int> (pull #194)
o Added .real(vector<IndexVal>), .cplx(vector<IndexVal>), etc.
o Added errMPOProd and deprecated checkMPOProd
o Test that new QN system allows mixing different site types
  (--> add MixedSiteSet to docs)
o New QN design:
  Store a smallstring along with QN value and mod fac. Storage is an array (fixed-size)
  of triples name-val-modfac.
o Remove IQTensor and IQIndex types, merging with ITensor and Index (also
  removed IQIndexVal, IQMPS, IQMPO, etc)
o All site sets except SiteSet(N,d) default to ConserveQNs=true
o Change default behavior of MPS(sites,m) constructor to be uninitialized MPS of size m
  o m>1 only allowed with no QNs
o Add randomMPS(SiteSet,m=1) function with no QNs
o Add randomMPS(InitState) function for QNs and no QNs
o Restore conversion of AutoMPO to MPO (allowing code like MPO(ampo)).
   o Add deprecation warning to MPO(AutoMPO), telling people to switch
     to toMPO(AutoMPO)
o Depecrate reindex(ITensor,Index,Index,...), replace with replaceInds(ITensor,Index,Index,...)
  that does not ignore prime levels and internally calls delta()
o Add deprecation error for Index("i",3) constructor pointing towards Index(3,...)
o Add deprecation warning for prime(ITensor,Index,int) pointing towards prime(ITensor,int,Index)
o Add read/write for TagSet
o Fix read/write for Index with QNs and test for rest of library
o Remove dependency of itensor/mps/localop.h in itensor/decomp.h (this seemed to be the only itensor/mps/ dependency left in itensor/)
o Deprecate randomTensor, matrixTensor, diagTensor in favor of randomITensor, matrixITensor, diagITensor
o Change name of findIndex(ITensor,Index) -> int to indexPosition(ITensor,Index) -> int
o Add findIndex(ITensor,TagSet,int) -> Index, which finds the Index in the ITensor containing certain tags and matching an optional prime level
o Add unit tests for tags functions (addTags, removeTags, swapTags, replaceTags, setTags)
o Better tag convention for labelling site index (i.e. "n=1" instead of "1" for site 1)
o Make sure that "Link" index keeps a consistent convention for labelling which link
  (i.e. MPS at site "n=4" should have left link with tags "Link,l=3" and right link with
   tags "Link,l=4")
o Implement dim(Index) -> long function as preferred alternative to I.m().
  Update documentation (especially ITensor book and Index synopsis).


Recent commits to v2 (master branch):
o errMPOProd and deprecation of checkMPOProd
o More combiner constructors (combiner(IndexSet), combiner(initializer_list), etc.)
o Bugfix for nmultMPO
o More combiner constructors (combiner(IndexSet), combiner(initializer_list), etc.)

